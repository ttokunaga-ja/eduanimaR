// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0

package sqlcgen

import (
	"database/sql"
	"database/sql/driver"
	"fmt"
	"time"

	uuid "github.com/google/uuid"
	pgvector "github.com/pgvector/pgvector-go"
	"github.com/sqlc-dev/pqtype"
)

type AuthProvider string

const (
	AuthProviderGoogle    AuthProvider = "google"
	AuthProviderMeta      AuthProvider = "meta"
	AuthProviderMicrosoft AuthProvider = "microsoft"
	AuthProviderLine      AuthProvider = "line"
)

func (e *AuthProvider) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = AuthProvider(s)
	case string:
		*e = AuthProvider(s)
	default:
		return fmt.Errorf("unsupported scan type for AuthProvider: %T", src)
	}
	return nil
}

type NullAuthProvider struct {
	AuthProvider AuthProvider `json:"auth_provider"`
	Valid        bool         `json:"valid"` // Valid is true if AuthProvider is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullAuthProvider) Scan(value interface{}) error {
	if value == nil {
		ns.AuthProvider, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.AuthProvider.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullAuthProvider) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.AuthProvider), nil
}

func (e AuthProvider) Valid() bool {
	switch e {
	case AuthProviderGoogle,
		AuthProviderMeta,
		AuthProviderMicrosoft,
		AuthProviderLine:
		return true
	}
	return false
}

func AllAuthProviderValues() []AuthProvider {
	return []AuthProvider{
		AuthProviderGoogle,
		AuthProviderMeta,
		AuthProviderMicrosoft,
		AuthProviderLine,
	}
}

type FileStatus string

const (
	FileStatusPending    FileStatus = "pending"
	FileStatusProcessing FileStatus = "processing"
	FileStatusReady      FileStatus = "ready"
	FileStatusFailed     FileStatus = "failed"
)

func (e *FileStatus) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = FileStatus(s)
	case string:
		*e = FileStatus(s)
	default:
		return fmt.Errorf("unsupported scan type for FileStatus: %T", src)
	}
	return nil
}

type NullFileStatus struct {
	FileStatus FileStatus `json:"file_status"`
	Valid      bool       `json:"valid"` // Valid is true if FileStatus is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullFileStatus) Scan(value interface{}) error {
	if value == nil {
		ns.FileStatus, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.FileStatus.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullFileStatus) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.FileStatus), nil
}

func (e FileStatus) Valid() bool {
	switch e {
	case FileStatusPending,
		FileStatusProcessing,
		FileStatusReady,
		FileStatusFailed:
		return true
	}
	return false
}

func AllFileStatusValues() []FileStatus {
	return []FileStatus{
		FileStatusPending,
		FileStatusProcessing,
		FileStatusReady,
		FileStatusFailed,
	}
}

type JobStatus string

const (
	JobStatusPending    JobStatus = "pending"
	JobStatusProcessing JobStatus = "processing"
	JobStatusCompleted  JobStatus = "completed"
	JobStatusFailed     JobStatus = "failed"
)

func (e *JobStatus) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = JobStatus(s)
	case string:
		*e = JobStatus(s)
	default:
		return fmt.Errorf("unsupported scan type for JobStatus: %T", src)
	}
	return nil
}

type NullJobStatus struct {
	JobStatus JobStatus `json:"job_status"`
	Valid     bool      `json:"valid"` // Valid is true if JobStatus is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullJobStatus) Scan(value interface{}) error {
	if value == nil {
		ns.JobStatus, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.JobStatus.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullJobStatus) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.JobStatus), nil
}

func (e JobStatus) Valid() bool {
	switch e {
	case JobStatusPending,
		JobStatusProcessing,
		JobStatusCompleted,
		JobStatusFailed:
		return true
	}
	return false
}

func AllJobStatusValues() []JobStatus {
	return []JobStatus{
		JobStatusPending,
		JobStatusProcessing,
		JobStatusCompleted,
		JobStatusFailed,
	}
}

type Chunk struct {
	ChunkID    uuid.UUID       `json:"chunk_id"`
	FileID     uuid.UUID       `json:"file_id"`
	SubjectID  uuid.UUID       `json:"subject_id"`
	PageNumber sql.NullInt32   `json:"page_number"`
	ChunkIndex int32           `json:"chunk_index"`
	Content    string          `json:"content"`
	Embedding  pgvector.Vector `json:"embedding"`
	CreatedAt  time.Time       `json:"created_at"`
}

type File struct {
	FileID       uuid.UUID      `json:"file_id"`
	SubjectID    uuid.UUID      `json:"subject_id"`
	UserID       uuid.UUID      `json:"user_id"`
	Name         string         `json:"name"`
	StoragePath  string         `json:"storage_path"`
	MimeType     string         `json:"mime_type"`
	SizeBytes    int64          `json:"size_bytes"`
	Status       FileStatus     `json:"status"`
	ErrorMessage sql.NullString `json:"error_message"`
	UploadedAt   time.Time      `json:"uploaded_at"`
	ProcessedAt  sql.NullTime   `json:"processed_at"`
}

type IngestJob struct {
	JobID        uuid.UUID      `json:"job_id"`
	FileID       uuid.UUID      `json:"file_id"`
	Status       JobStatus      `json:"status"`
	RetryCount   int32          `json:"retry_count"`
	MaxRetries   int32          `json:"max_retries"`
	ErrorMessage sql.NullString `json:"error_message"`
	CreatedAt    time.Time      `json:"created_at"`
	StartedAt    sql.NullTime   `json:"started_at"`
	CompletedAt  sql.NullTime   `json:"completed_at"`
}

type QaSession struct {
	SessionID  uuid.UUID             `json:"session_id"`
	UserID     uuid.UUID             `json:"user_id"`
	SubjectID  uuid.UUID             `json:"subject_id"`
	Question   string                `json:"question"`
	Answer     sql.NullString        `json:"answer"`
	Sources    pqtype.NullRawMessage `json:"sources"`
	Feedback   sql.NullInt16         `json:"feedback"`
	CreatedAt  time.Time             `json:"created_at"`
	AnsweredAt sql.NullTime          `json:"answered_at"`
}

type Subject struct {
	SubjectID   uuid.UUID      `json:"subject_id"`
	UserID      uuid.UUID      `json:"user_id"`
	Name        string         `json:"name"`
	LmsCourseID sql.NullString `json:"lms_course_id"`
	CreatedAt   time.Time      `json:"created_at"`
	UpdatedAt   time.Time      `json:"updated_at"`
}

type User struct {
	UserID         uuid.UUID        `json:"user_id"`
	Email          string           `json:"email"`
	Provider       NullAuthProvider `json:"provider"`
	ProviderUserID sql.NullString   `json:"provider_user_id"`
	CreatedAt      time.Time        `json:"created_at"`
	UpdatedAt      time.Time        `json:"updated_at"`
}
