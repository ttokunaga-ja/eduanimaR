// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: chunks.sql

package sqlcgen

import (
	"context"
	"database/sql"
	"time"

	uuid "github.com/google/uuid"
	pgvector "github.com/pgvector/pgvector-go"
)

const deleteChunksByFileID = `-- name: DeleteChunksByFileID :exec
DELETE FROM chunks
WHERE file_id = $1
`

func (q *Queries) DeleteChunksByFileID(ctx context.Context, fileID uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, deleteChunksByFileID, fileID)
	return err
}

const insertChunk = `-- name: InsertChunk :one
INSERT INTO chunks (
    chunk_id,
    file_id,
    subject_id,
    page_number,
    chunk_index,
    content,
    embedding
)
VALUES ($1, $2, $3, $4, $5, $6, $7)
RETURNING chunk_id, file_id, subject_id, page_number, chunk_index, content, embedding, created_at
`

type InsertChunkParams struct {
	ChunkID    uuid.UUID       `json:"chunk_id"`
	FileID     uuid.UUID       `json:"file_id"`
	SubjectID  uuid.UUID       `json:"subject_id"`
	PageNumber sql.NullInt32   `json:"page_number"`
	ChunkIndex int32           `json:"chunk_index"`
	Content    string          `json:"content"`
	Embedding  pgvector.Vector `json:"embedding"`
}

func (q *Queries) InsertChunk(ctx context.Context, arg InsertChunkParams) (Chunk, error) {
	row := q.db.QueryRowContext(ctx, insertChunk,
		arg.ChunkID,
		arg.FileID,
		arg.SubjectID,
		arg.PageNumber,
		arg.ChunkIndex,
		arg.Content,
		arg.Embedding,
	)
	var i Chunk
	err := row.Scan(
		&i.ChunkID,
		&i.FileID,
		&i.SubjectID,
		&i.PageNumber,
		&i.ChunkIndex,
		&i.Content,
		&i.Embedding,
		&i.CreatedAt,
	)
	return i, err
}

const listChunksByFileID = `-- name: ListChunksByFileID :many

SELECT chunk_id, file_id, subject_id, page_number, chunk_index, content, embedding, created_at
FROM chunks
WHERE file_id = $1
ORDER BY chunk_index
`

// sql/queries/chunks.sql
func (q *Queries) ListChunksByFileID(ctx context.Context, fileID uuid.UUID) ([]Chunk, error) {
	rows, err := q.db.QueryContext(ctx, listChunksByFileID, fileID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Chunk
	for rows.Next() {
		var i Chunk
		if err := rows.Scan(
			&i.ChunkID,
			&i.FileID,
			&i.SubjectID,
			&i.PageNumber,
			&i.ChunkIndex,
			&i.Content,
			&i.Embedding,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchChunksByText = `-- name: SearchChunksByText :many
SELECT
    chunk_id,
    file_id,
    subject_id,
    page_number,
    chunk_index,
    content,
    created_at
FROM chunks
WHERE subject_id = $2
  AND to_tsvector('simple', content) @@ plainto_tsquery('simple', $1)
ORDER BY ts_rank(to_tsvector('simple', content), plainto_tsquery('simple', $1)) DESC
LIMIT $3
`

type SearchChunksByTextParams struct {
	PlaintoTsquery string    `json:"plainto_tsquery"`
	SubjectID      uuid.UUID `json:"subject_id"`
	Limit          int32     `json:"limit"`
}

type SearchChunksByTextRow struct {
	ChunkID    uuid.UUID     `json:"chunk_id"`
	FileID     uuid.UUID     `json:"file_id"`
	SubjectID  uuid.UUID     `json:"subject_id"`
	PageNumber sql.NullInt32 `json:"page_number"`
	ChunkIndex int32         `json:"chunk_index"`
	Content    string        `json:"content"`
	CreatedAt  time.Time     `json:"created_at"`
}

// 全文検索（simple 辞書 / plainto_tsquery）
// $1: query_text, $2: subject_id, $3: limit
func (q *Queries) SearchChunksByText(ctx context.Context, arg SearchChunksByTextParams) ([]SearchChunksByTextRow, error) {
	rows, err := q.db.QueryContext(ctx, searchChunksByText, arg.PlaintoTsquery, arg.SubjectID, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SearchChunksByTextRow
	for rows.Next() {
		var i SearchChunksByTextRow
		if err := rows.Scan(
			&i.ChunkID,
			&i.FileID,
			&i.SubjectID,
			&i.PageNumber,
			&i.ChunkIndex,
			&i.Content,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchChunksByVector = `-- name: SearchChunksByVector :many
SELECT
    chunk_id,
    file_id,
    subject_id,
    page_number,
    chunk_index,
    content,
    created_at
FROM chunks
WHERE subject_id = $2
ORDER BY embedding <=> $1::vector
LIMIT $3
`

type SearchChunksByVectorParams struct {
	Column1   pgvector.Vector `json:"column_1"`
	SubjectID uuid.UUID       `json:"subject_id"`
	Limit     int32           `json:"limit"`
}

type SearchChunksByVectorRow struct {
	ChunkID    uuid.UUID     `json:"chunk_id"`
	FileID     uuid.UUID     `json:"file_id"`
	SubjectID  uuid.UUID     `json:"subject_id"`
	PageNumber sql.NullInt32 `json:"page_number"`
	ChunkIndex int32         `json:"chunk_index"`
	Content    string        `json:"content"`
	CreatedAt  time.Time     `json:"created_at"`
}

// コサイン類似度でのベクトル検索（HNSW インデックス使用）
// $1: query_embedding (vector), $2: subject_id, $3: limit
func (q *Queries) SearchChunksByVector(ctx context.Context, arg SearchChunksByVectorParams) ([]SearchChunksByVectorRow, error) {
	rows, err := q.db.QueryContext(ctx, searchChunksByVector, arg.Column1, arg.SubjectID, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SearchChunksByVectorRow
	for rows.Next() {
		var i SearchChunksByVectorRow
		if err := rows.Scan(
			&i.ChunkID,
			&i.FileID,
			&i.SubjectID,
			&i.PageNumber,
			&i.ChunkIndex,
			&i.Content,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
