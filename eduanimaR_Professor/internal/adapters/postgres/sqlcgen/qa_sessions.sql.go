// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: qa_sessions.sql

package sqlcgen

import (
	"context"
	"database/sql"

	uuid "github.com/google/uuid"
	"github.com/sqlc-dev/pqtype"
)

const countQASessionsBySubjectID = `-- name: CountQASessionsBySubjectID :one
SELECT COUNT(*)
FROM qa_sessions
WHERE subject_id = $1
  AND user_id    = $2
`

type CountQASessionsBySubjectIDParams struct {
	SubjectID uuid.UUID `json:"subject_id"`
	UserID    uuid.UUID `json:"user_id"`
}

func (q *Queries) CountQASessionsBySubjectID(ctx context.Context, arg CountQASessionsBySubjectIDParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, countQASessionsBySubjectID, arg.SubjectID, arg.UserID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createQASession = `-- name: CreateQASession :one

INSERT INTO qa_sessions (session_id, user_id, subject_id, question)
VALUES ($1, $2, $3, $4)
RETURNING session_id, user_id, subject_id, question, answer, sources, feedback, created_at, answered_at
`

type CreateQASessionParams struct {
	SessionID uuid.UUID `json:"session_id"`
	UserID    uuid.UUID `json:"user_id"`
	SubjectID uuid.UUID `json:"subject_id"`
	Question  string    `json:"question"`
}

// sql/queries/qa_sessions.sql
func (q *Queries) CreateQASession(ctx context.Context, arg CreateQASessionParams) (QaSession, error) {
	row := q.db.QueryRowContext(ctx, createQASession,
		arg.SessionID,
		arg.UserID,
		arg.SubjectID,
		arg.Question,
	)
	var i QaSession
	err := row.Scan(
		&i.SessionID,
		&i.UserID,
		&i.SubjectID,
		&i.Question,
		&i.Answer,
		&i.Sources,
		&i.Feedback,
		&i.CreatedAt,
		&i.AnsweredAt,
	)
	return i, err
}

const getQASessionByID = `-- name: GetQASessionByID :one
SELECT session_id, user_id, subject_id, question, answer, sources, feedback, created_at, answered_at
FROM qa_sessions
WHERE session_id = $1
`

func (q *Queries) GetQASessionByID(ctx context.Context, sessionID uuid.UUID) (QaSession, error) {
	row := q.db.QueryRowContext(ctx, getQASessionByID, sessionID)
	var i QaSession
	err := row.Scan(
		&i.SessionID,
		&i.UserID,
		&i.SubjectID,
		&i.Question,
		&i.Answer,
		&i.Sources,
		&i.Feedback,
		&i.CreatedAt,
		&i.AnsweredAt,
	)
	return i, err
}

const getQASessionByIDAndUserID = `-- name: GetQASessionByIDAndUserID :one
SELECT session_id, user_id, subject_id, question, answer, sources, feedback, created_at, answered_at
FROM qa_sessions
WHERE session_id = $1
  AND user_id    = $2
`

type GetQASessionByIDAndUserIDParams struct {
	SessionID uuid.UUID `json:"session_id"`
	UserID    uuid.UUID `json:"user_id"`
}

func (q *Queries) GetQASessionByIDAndUserID(ctx context.Context, arg GetQASessionByIDAndUserIDParams) (QaSession, error) {
	row := q.db.QueryRowContext(ctx, getQASessionByIDAndUserID, arg.SessionID, arg.UserID)
	var i QaSession
	err := row.Scan(
		&i.SessionID,
		&i.UserID,
		&i.SubjectID,
		&i.Question,
		&i.Answer,
		&i.Sources,
		&i.Feedback,
		&i.CreatedAt,
		&i.AnsweredAt,
	)
	return i, err
}

const listQASessionsBySubjectID = `-- name: ListQASessionsBySubjectID :many
SELECT
    session_id, user_id, subject_id,
    question, answer, sources, feedback,
    created_at, answered_at
FROM qa_sessions
WHERE subject_id = $1
  AND user_id    = $2
ORDER BY created_at DESC
LIMIT  $3
OFFSET $4
`

type ListQASessionsBySubjectIDParams struct {
	SubjectID uuid.UUID `json:"subject_id"`
	UserID    uuid.UUID `json:"user_id"`
	Limit     int32     `json:"limit"`
	Offset    int32     `json:"offset"`
}

func (q *Queries) ListQASessionsBySubjectID(ctx context.Context, arg ListQASessionsBySubjectIDParams) ([]QaSession, error) {
	rows, err := q.db.QueryContext(ctx, listQASessionsBySubjectID,
		arg.SubjectID,
		arg.UserID,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []QaSession
	for rows.Next() {
		var i QaSession
		if err := rows.Scan(
			&i.SessionID,
			&i.UserID,
			&i.SubjectID,
			&i.Question,
			&i.Answer,
			&i.Sources,
			&i.Feedback,
			&i.CreatedAt,
			&i.AnsweredAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateQASessionAnswer = `-- name: UpdateQASessionAnswer :one
UPDATE qa_sessions
SET
    answer      = $2,
    sources     = $3,
    answered_at = NOW()
WHERE session_id = $1
RETURNING session_id, user_id, subject_id, question, answer, sources, feedback, created_at, answered_at
`

type UpdateQASessionAnswerParams struct {
	SessionID uuid.UUID             `json:"session_id"`
	Answer    sql.NullString        `json:"answer"`
	Sources   pqtype.NullRawMessage `json:"sources"`
}

func (q *Queries) UpdateQASessionAnswer(ctx context.Context, arg UpdateQASessionAnswerParams) (QaSession, error) {
	row := q.db.QueryRowContext(ctx, updateQASessionAnswer, arg.SessionID, arg.Answer, arg.Sources)
	var i QaSession
	err := row.Scan(
		&i.SessionID,
		&i.UserID,
		&i.SubjectID,
		&i.Question,
		&i.Answer,
		&i.Sources,
		&i.Feedback,
		&i.CreatedAt,
		&i.AnsweredAt,
	)
	return i, err
}

const updateQASessionFeedback = `-- name: UpdateQASessionFeedback :one
UPDATE qa_sessions
SET feedback = $2
WHERE session_id = $1
  AND user_id    = $3
RETURNING session_id, user_id, subject_id, question, answer, sources, feedback, created_at, answered_at
`

type UpdateQASessionFeedbackParams struct {
	SessionID uuid.UUID     `json:"session_id"`
	Feedback  sql.NullInt16 `json:"feedback"`
	UserID    uuid.UUID     `json:"user_id"`
}

func (q *Queries) UpdateQASessionFeedback(ctx context.Context, arg UpdateQASessionFeedbackParams) (QaSession, error) {
	row := q.db.QueryRowContext(ctx, updateQASessionFeedback, arg.SessionID, arg.Feedback, arg.UserID)
	var i QaSession
	err := row.Scan(
		&i.SessionID,
		&i.UserID,
		&i.SubjectID,
		&i.Question,
		&i.Answer,
		&i.Sources,
		&i.Feedback,
		&i.CreatedAt,
		&i.AnsweredAt,
	)
	return i, err
}
